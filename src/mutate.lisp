(defun find-size (tree)
  (if (typep tree 'list)
    (let ((ans 1))  ; starts at one because this itself is a spot
      (dolist (sub (rest tree))
        (incf ans (find-size sub)))
      ans)
    1))

(defun get-type (tree primitives)
  (let ((prim (if (typep tree 'list) (first tree) tree))
        (key NIL))
    (if (typep prim 'number) (return-from get-type :number))
    (dolist (i primitives)
      (if (typep i 'keyword)
        (setf key i)
        (dolist (j i)
          (when (equalp prim (first j))
            (return-from get-type key)))))))

(defun change-subtree (tree spot goal depth primitives)
  ;(print (list tree spot goal depth))
  (cond
    ((> spot goal)
     ;(format t "Greater than..just return ~a~%" tree)
     (list spot (list tree)))
    ((= spot goal)
     ;(format t "Equal!  Type is ~a.  Mutation is:~%" (get-type tree primitives))
     (let ((rand (build-tree depth primitives (get-type tree primitives))))
       (list (1+ goal) (list rand))))
    ((< spot goal)
     ;(format t "Less than..better start building.~%")
     (if (typep tree 'list)
       (progn (let ((ans (list (first tree)))
                    (x (1+ spot)))
                (dolist (i (rest tree))
                  ;(format t "~a a Result was (~a ~a)~%" spot x ans)
                  (setf res (change-subtree i x goal depth primitives))
                  ;(format t "~a b Result was (~a ~a)~%" spot x ans)
                  ;(format t "Got ~a~%" res)
                  (setf x (first res))
                  (setf ans (concatenate 'list ans (second res))))
                  ;(format t "Result now (~a ~a)~%" x ans))
                (list x (list ans))))
       (list (1+ spot) (list tree))))))

(defun mutate (tree depth primitives)
  (caadr (change-subtree tree 0 (random (find-size tree)) depth primitives)))
