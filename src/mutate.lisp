(defun find-depths (tree depth)
  (if (typep tree 'list)
    (let ((ans (list depth)))
      (dolist (sub (rest tree))
        (setf ans (concatenate 'list ans (find-depths sub (1+ depth)))))
      ans)
    (list depth)))

(defun find-hood (depth)
  (1+ depth))

(defun get-type (tree primitives)
  (let ((prim (if (typep tree 'list) (first tree) tree))
        (key NIL))
    (dolist (i primitives)
      (if (typep i 'keyword)
        (setf key i)
        (dolist (j i)
          (when (or (equalp prim (first j))
                    (and (typep prim 'number) (typep (first j) 'array)))
            (return-from get-type key)))))))

(defun change-subtree (tree spot goal depth primitives)
  (cond
    ((> spot goal)
     (list spot (list tree)))
    ((= spot goal)
     (let ((rand (build-tree depth primitives (get-type tree primitives))))
       (list (1+ goal) (list rand))))
    ((< spot goal)
     (if (and tree (typep tree 'list))
       (progn (let ((ans (list (first tree)))
                    (x (1+ spot))
                    (res NIL))
                (dolist (i (rest tree))
                  (setf res (change-subtree i x goal depth primitives))
                  (setf x (first res))
                  (setf ans (concatenate 'list ans (second res))))
                (list x (list ans))))
       (list (1+ spot) (list tree))))))

(defun mutate (tree depth primitives)
  (let* ((depths (find-depths tree 0))
         (likelihoods (mapcar #'find-hood depths))
         (spot (find-spot (map 'list
                               #'list
                               likelihoods
                               (range 0 (length likelihoods))))))
    (let ((ans (change-subtree tree 0 spot depth primitives)))
      (caadr ans))))
